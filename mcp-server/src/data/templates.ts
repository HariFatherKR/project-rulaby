// Auto-generated template data - DO NOT EDIT
// Generated on: 2025-07-24T00:09:57.612Z

export interface Template {
  name: string;
  content: string;
  category: string;
}

export const templates: Record<string, Template> = {
  "clean-code": {
    "name": "clean-code",
    "content": "# Clean Code Guidelines\n\n## Constants Over Magic Numbers\n- Replace hard-coded values with named constants\n- Use descriptive constant names that explain the value's purpose\n- Keep constants at the top of the file or in a dedicated constants file\n\n## Meaningful Names\n- Variables, functions, and classes should reveal their purpose\n- Names should explain why something exists and how it's used\n- Avoid abbreviations unless they're universally understood\n\n## Smart Comments\n- Don't comment on what the code does - make the code self-documenting\n- Use comments to explain why something is done a certain way\n- Document APIs, complex algorithms, and non-obvious side effects\n\n## Single Responsibility\n- Each function should do exactly one thing\n- Functions should be small and focused\n- If a function needs a comment to explain what it does, it should be split\n\n## DRY (Don't Repeat Yourself)\n- Extract repeated code into reusable functions\n- Share common logic through proper abstraction\n- Maintain single sources of truth\n\n## Clean Structure\n- Keep related code together\n- Organize code in a logical hierarchy\n- Use consistent file and folder naming conventions\n\n## Encapsulation\n- Hide implementation details\n- Expose clear interfaces\n- Move nested conditionals into well-named functions\n\n## Code Quality Maintenance\n- Refactor continuously\n- Fix technical debt early\n- Leave code cleaner than you found it\n\n## Testing\n- Write tests before fixing bugs\n- Keep tests readable and maintainable\n- Test edge cases and error conditions\n\n## Version Control\n- Write clear commit messages\n- Make small, focused commits\n- Use meaningful branch names",
    "category": "style"
  },
  "codequality": {
    "name": "codequality",
    "content": "# Code Quality Guidelines\n\n## Verify Information\nAlways verify information before presenting it. Do not make assumptions or speculate without clear evidence.\n\n## File-by-File Changes\nMake changes file by file and give me a chance to spot mistakes.\n\n## No Apologies\nNever use apologies.\n\n## No Understanding Feedback\nAvoid giving feedback about understanding in comments or documentation.\n\n## No Whitespace Suggestions\nDon't suggest whitespace changes.\n\n## No Summaries\nDon't summarize changes made.\n\n## No Inventions\nDon't invent changes other than what's explicitly requested.\n\n## No Unnecessary Confirmations\nDon't ask for confirmation of information already provided in the context.\n\n## Preserve Existing Code\nDon't remove unrelated code or functionalities. Pay attention to preserving existing structures.\n\n## Single Chunk Edits\nProvide all edits in a single chunk instead of multiple-step instructions or explanations for the same file.\n\n## No Implementation Checks\nDon't ask the user to verify implementations that are visible in the provided context.\n\n## No Unnecessary Updates\nDon't suggest updates or changes to files when there are no actual modifications needed.\n\n## Provide Real File Links\nAlways provide links to the real files, not x.md.\n\n## No Current Implementation\nDon't show or discuss the current implementation unless specifically requested.",
    "category": "style"
  },
  "database": {
    "name": "database",
    "content": "# Database Best Practices\n\n## Prisma Setup\n- Use proper schema design\n- Implement proper migrations\n- Use proper relation definitions\n- Configure proper connection\n- Implement proper seeding\n- Use proper client setup\n\n## Prisma Models\n- Use proper model naming\n- Implement proper relations\n- Use proper field types\n- Define proper indexes\n- Implement proper constraints\n- Use proper enums\n\n## Prisma Queries\n- Use proper query optimization\n- Implement proper filtering\n- Use proper relations loading\n- Handle transactions properly\n- Implement proper pagination\n- Use proper aggregations\n\n## Supabase Setup\n- Configure proper project setup\n- Implement proper authentication\n- Use proper database setup\n- Configure proper storage\n- Implement proper policies\n- Use proper client setup\n\n## Supabase Security\n- Implement proper RLS policies\n- Use proper authentication\n- Configure proper permissions\n- Handle sensitive data properly\n- Implement proper backups\n- Use proper encryption\n\n## Supabase Queries\n- Use proper query optimization\n- Implement proper filtering\n- Use proper joins\n- Handle real-time properly\n- Implement proper pagination\n- Use proper functions\n\n## Database Design\n- Use proper normalization\n- Implement proper indexing\n- Use proper constraints\n- Define proper relations\n- Implement proper cascades\n- Use proper data types\n\n## Performance\n- Use proper connection pooling\n- Implement proper caching\n- Use proper query optimization\n- Handle N+1 queries properly\n- Implement proper batching\n- Monitor performance metrics\n\n## Security\n- Use proper authentication\n- Implement proper authorization\n- Handle sensitive data properly\n- Use proper encryption\n- Implement proper backups\n- Monitor security issues\n\n## Best Practices\n- Follow database conventions\n- Use proper migrations\n- Implement proper versioning\n- Handle errors properly\n- Document schema properly\n- Monitor database health",
    "category": "backend"
  },
  "fastapi": {
    "name": "fastapi",
    "content": "# FastAPI Best Practices\n\n## Project Structure\n- Use proper directory structure\n- Implement proper module organization\n- Use proper dependency injection\n- Keep routes organized by domain\n- Implement proper middleware\n- Use proper configuration management\n\n## API Design\n- Use proper HTTP methods\n- Implement proper status codes\n- Use proper request/response models\n- Implement proper validation\n- Use proper error handling\n- Document APIs with OpenAPI\n\n## Models\n- Use Pydantic models\n- Implement proper validation\n- Use proper type hints\n- Keep models organized\n- Use proper inheritance\n- Implement proper serialization\n\n## Database\n- Use proper ORM (SQLAlchemy)\n- Implement proper migrations\n- Use proper connection pooling\n- Implement proper transactions\n- Use proper query optimization\n- Handle database errors properly\n\n## Authentication\n- Implement proper JWT authentication\n- Use proper password hashing\n- Implement proper role-based access\n- Use proper session management\n- Implement proper OAuth2\n- Handle authentication errors properly\n\n## Security\n- Implement proper CORS\n- Use proper rate limiting\n- Implement proper input validation\n- Use proper security headers\n- Handle security errors properly\n- Implement proper logging\n\n## Performance\n- Use proper caching\n- Implement proper async operations\n- Use proper background tasks\n- Implement proper connection pooling\n- Use proper query optimization\n- Monitor performance metrics\n\n## Testing\n- Write proper unit tests\n- Implement proper integration tests\n- Use proper test fixtures\n- Implement proper mocking\n- Test error scenarios\n- Use proper test coverage\n\n## Deployment\n- Use proper Docker configuration\n- Implement proper CI/CD\n- Use proper environment variables\n- Implement proper logging\n- Use proper monitoring\n- Handle deployment errors properly\n\n## Documentation\n- Use proper docstrings\n- Implement proper API documentation\n- Use proper type hints\n- Keep documentation updated\n- Document error scenarios\n- Use proper versioning",
    "category": "backend"
  },
  "gitflow": {
    "name": "gitflow",
    "content": "# Gitflow Workflow Rules\n\n## Main Branches\n\n### main (or master)\n- Contains production-ready code\n- Never commit directly to main\n- Only accepts merges from:\n  - hotfix/* branches\n  - release/* branches\n- Must be tagged with version number after each merge\n\n### develop\n- Main development branch\n- Contains latest delivered development changes\n- Source branch for feature branches\n- Never commit directly to develop\n\n## Supporting Branches\n\n### feature/*\n- Branch from: develop\n- Merge back into: develop\n- Naming convention: feature/[issue-id]-descriptive-name\n- Example: feature/123-user-authentication\n- Must be up-to-date with develop before creating PR\n- Delete after merge\n\n### release/*\n- Branch from: develop\n- Merge back into: \n  - main\n  - develop\n- Naming convention: release/vX.Y.Z\n- Example: release/v1.2.0\n- Only bug fixes, documentation, and release-oriented tasks\n- No new features\n- Delete after merge\n\n### hotfix/*\n- Branch from: main\n- Merge back into:\n  - main\n  - develop\n- Naming convention: hotfix/vX.Y.Z\n- Example: hotfix/v1.2.1\n- Only for urgent production fixes\n- Delete after merge\n\n## Commit Messages\n\n- Format: `type(scope): description`\n- Types:\n  - feat: New feature\n  - fix: Bug fix\n  - docs: Documentation changes\n  - style: Formatting, missing semicolons, etc.\n  - refactor: Code refactoring\n  - test: Adding tests\n  - chore: Maintenance tasks\n\n## Version Control\n\n### Semantic Versioning\n- MAJOR version for incompatible API changes\n- MINOR version for backwards-compatible functionality\n- PATCH version for backwards-compatible bug fixes\n\n## Pull Request Rules\n\n1. All changes must go through Pull Requests\n2. Required approvals: minimum 1\n3. CI checks must pass\n4. No direct commits to protected branches (main, develop)\n5. Branch must be up to date before merging\n6. Delete branch after merge\n\n## Branch Protection Rules\n\n### main & develop\n- Require pull request reviews\n- Require status checks to pass\n- Require branches to be up to date\n- Include administrators in restrictions\n- No force pushes\n- No deletions\n\n## Release Process\n\n1. Create release branch from develop\n2. Bump version numbers\n3. Fix any release-specific issues\n4. Create PR to main\n5. After merge to main:\n   - Tag release\n   - Merge back to develop\n   - Delete release branch\n\n## Hotfix Process\n\n1. Create hotfix branch from main\n2. Fix the issue\n3. Bump patch version\n4. Create PR to main\n5. After merge to main:\n   - Tag release\n   - Merge back to develop\n   - Delete hotfix branch",
    "category": "workflow"
  },
  "nextjs": {
    "name": "nextjs",
    "content": "# Next.js Best Practices\n\n## Project Structure\n- Use the App Router directory structure\n- Place components in `app` directory for route-specific components\n- Place shared components in `components` directory\n- Place utilities and helpers in `lib` directory\n- Use lowercase with dashes for directories (e.g., `components/auth-wizard`)\n\n## Components\n- Use Server Components by default\n- Mark client components explicitly with 'use client'\n- Wrap client components in Suspense with fallback\n- Use dynamic loading for non-critical components\n- Implement proper error boundaries\n- Place static content and interfaces at file end\n\n## Performance\n- Optimize images: Use WebP format, size data, lazy loading\n- Minimize use of 'useEffect' and 'setState'\n- Favor Server Components (RSC) where possible\n- Use dynamic loading for non-critical components\n- Implement proper caching strategies\n\n## Data Fetching\n- Use Server Components for data fetching when possible\n- Implement proper error handling for data fetching\n- Use appropriate caching strategies\n- Handle loading and error states appropriately\n\n## Routing\n- Use the App Router conventions\n- Implement proper loading and error states for routes\n- Use dynamic routes appropriately\n- Handle parallel routes when needed\n\n## Forms and Validation\n- Use Zod for form validation\n- Implement proper server-side validation\n- Handle form errors appropriately\n- Show loading states during form submission\n\n## State Management\n- Minimize client-side state\n- Use React Context sparingly\n- Prefer server state when possible\n- Implement proper loading states",
    "category": "framework"
  },
  "node-express": {
    "name": "node-express",
    "content": "# Node.js and Express.js Best Practices\n\n## Project Structure\n- Use proper directory structure\n- Implement proper module organization\n- Use proper middleware organization\n- Keep routes organized by domain\n- Implement proper error handling\n- Use proper configuration management\n\n## Express Setup\n- Use proper middleware setup\n- Implement proper routing\n- Use proper error handling\n- Configure proper security middleware\n- Implement proper validation\n- Use proper static file serving\n\n## API Design\n- Use proper REST principles\n- Implement proper versioning\n- Use proper request validation\n- Handle errors properly\n- Implement proper response formats\n- Document APIs properly\n\n## Database Integration\n- Use proper ORM/ODM\n- Implement proper migrations\n- Use proper connection pooling\n- Implement proper transactions\n- Use proper query optimization\n- Handle database errors properly\n\n## Authentication\n- Implement proper JWT handling\n- Use proper password hashing\n- Implement proper session management\n- Use proper OAuth integration\n- Implement proper role-based access\n- Handle auth errors properly\n\n## Security\n- Use proper CORS setup\n- Implement proper rate limiting\n- Use proper security headers\n- Implement proper input validation\n- Use proper encryption\n- Handle security vulnerabilities\n\n## Performance\n- Use proper caching\n- Implement proper async operations\n- Use proper connection pooling\n- Implement proper logging\n- Use proper monitoring\n- Handle high traffic properly\n\n## Testing\n- Write proper unit tests\n- Implement proper integration tests\n- Use proper test runners\n- Implement proper mocking\n- Test error scenarios\n- Use proper test coverage\n\n## Deployment\n- Use proper Docker setup\n- Implement proper CI/CD\n- Use proper environment variables\n- Configure proper logging\n- Implement proper monitoring\n- Handle deployment errors\n\n## Best Practices\n- Follow Node.js best practices\n- Use proper async/await\n- Implement proper error handling\n- Use proper logging\n- Handle process signals properly\n- Document code properly",
    "category": "backend"
  },
  "python": {
    "name": "python",
    "content": "# Python Best Practices\n\n## Project Structure\n- Use src-layout with `src/your_package_name/`\n- Place tests in `tests/` directory parallel to `src/`\n- Keep configuration in `config/` or as environment variables\n- Store requirements in `requirements.txt` or `pyproject.toml`\n- Place static files in `static/` directory\n- Use `templates/` for Jinja2 templates\n\n## Code Style\n- Follow Black code formatting\n- Use isort for import sorting\n- Follow PEP 8 naming conventions:\n  - snake_case for functions and variables\n  - PascalCase for classes\n  - UPPER_CASE for constants\n- Maximum line length of 88 characters (Black default)\n- Use absolute imports over relative imports\n\n## Type Hints\n- Use type hints for all function parameters and returns\n- Import types from `typing` module\n- Use `Optional[Type]` instead of `Type | None`\n- Use `TypeVar` for generic types\n- Define custom types in `types.py`\n- Use `Protocol` for duck typing\n\n## Flask Structure\n- Use Flask factory pattern\n- Organize routes using Blueprints\n- Use Flask-SQLAlchemy for database\n- Implement proper error handlers\n- Use Flask-Login for authentication\n- Structure views with proper separation of concerns\n\n## Database\n- Use SQLAlchemy ORM\n- Implement database migrations with Alembic\n- Use proper connection pooling\n- Define models in separate modules\n- Implement proper relationships\n- Use proper indexing strategies\n\n## Authentication\n- Use Flask-Login for session management\n- Implement Google OAuth using Flask-OAuth\n- Hash passwords with bcrypt\n- Use proper session security\n- Implement CSRF protection\n- Use proper role-based access control\n\n## API Design\n- Use Flask-RESTful for REST APIs\n- Implement proper request validation\n- Use proper HTTP status codes\n- Handle errors consistently\n- Use proper response formats\n- Implement proper rate limiting\n\n## Testing\n- Use pytest for testing\n- Write tests for all routes\n- Use pytest-cov for coverage\n- Implement proper fixtures\n- Use proper mocking with pytest-mock\n- Test all error scenarios\n\n## Security\n- Use HTTPS in production\n- Implement proper CORS\n- Sanitize all user inputs\n- Use proper session configuration\n- Implement proper logging\n- Follow OWASP guidelines\n\n## Performance\n- Use proper caching with Flask-Caching\n- Implement database query optimization\n- Use proper connection pooling\n- Implement proper pagination\n- Use background tasks for heavy operations\n- Monitor application performance\n\n## Error Handling\n- Create custom exception classes\n- Use proper try-except blocks\n- Implement proper logging\n- Return proper error responses\n- Handle edge cases properly\n- Use proper error messages\n\n## Documentation\n- Use Google-style docstrings\n- Document all public APIs\n- Keep README.md updated\n- Use proper inline comments\n- Generate API documentation\n- Document environment setup\n\n## Development Workflow\n- Use virtual environments (venv)\n- Implement pre-commit hooks\n- Use proper Git workflow\n- Follow semantic versioning\n- Use proper CI/CD practices\n- Implement proper logging\n\n## Dependencies\n- Pin dependency versions\n- Use requirements.txt for production\n- Separate dev dependencies\n- Use proper package versions\n- Regularly update dependencies\n- Check for security vulnerabilities",
    "category": "language"
  },
  "react": {
    "name": "react",
    "content": "# React Best Practices\n\n## Component Structure\n- Use functional components over class components\n- Keep components small and focused\n- Extract reusable logic into custom hooks\n- Use composition over inheritance\n- Implement proper prop types with TypeScript\n- Split large components into smaller, focused ones\n\n## Hooks\n- Follow the Rules of Hooks\n- Use custom hooks for reusable logic\n- Keep hooks focused and simple\n- Use appropriate dependency arrays in useEffect\n- Implement cleanup in useEffect when needed\n- Avoid nested hooks\n\n## State Management\n- Use useState for local component state\n- Implement useReducer for complex state logic\n- Use Context API for shared state\n- Keep state as close to where it's used as possible\n- Avoid prop drilling through proper state management\n- Use state management libraries only when necessary\n\n## Performance\n- Implement proper memoization (useMemo, useCallback)\n- Use React.memo for expensive components\n- Avoid unnecessary re-renders\n- Implement proper lazy loading\n- Use proper key props in lists\n- Profile and optimize render performance\n\n## Forms\n- Use controlled components for form inputs\n- Implement proper form validation\n- Handle form submission states properly\n- Show appropriate loading and error states\n- Use form libraries for complex forms\n- Implement proper accessibility for forms\n\n## Error Handling\n- Implement Error Boundaries\n- Handle async errors properly\n- Show user-friendly error messages\n- Implement proper fallback UI\n- Log errors appropriately\n- Handle edge cases gracefully\n\n## Testing\n- Write unit tests for components\n- Implement integration tests for complex flows\n- Use React Testing Library\n- Test user interactions\n- Test error scenarios\n- Implement proper mock data\n\n## Accessibility\n- Use semantic HTML elements\n- Implement proper ARIA attributes\n- Ensure keyboard navigation\n- Test with screen readers\n- Handle focus management\n- Provide proper alt text for images\n\n## Code Organization\n- Group related components together\n- Use proper file naming conventions\n- Implement proper directory structure\n- Keep styles close to components\n- Use proper imports/exports\n- Document complex component logic",
    "category": "framework"
  },
  "svelte": {
    "name": "svelte",
    "content": "# Svelte Best Practices\n\n## Component Structure\n- Keep components small and focused\n- Use proper TypeScript integration\n- Implement proper props typing\n- Use proper event dispatching\n- Keep markup clean and readable\n- Use proper slot implementation\n\n## Reactivity\n- Use proper reactive declarations\n- Implement proper stores\n- Use proper reactive statements\n- Handle derived values properly\n- Use proper lifecycle functions\n- Implement proper bindings\n\n## State Management\n- Use proper Svelte stores\n- Keep stores modular\n- Use proper derived stores\n- Implement proper actions\n- Handle async state properly\n- Use proper store subscriptions\n\n## Performance\n- Use proper component lazy loading\n- Implement proper transitions\n- Use proper animations\n- Avoid unnecessary reactivity\n- Use proper event forwarding\n- Implement proper key blocks\n\n## Routing\n- Use SvelteKit for routing\n- Implement proper layouts\n- Use proper route parameters\n- Handle loading states properly\n- Implement proper error pages\n- Use proper navigation methods\n\n## Forms\n- Use proper form bindings\n- Implement proper validation\n- Handle form submission properly\n- Show proper loading states\n- Use proper error handling\n- Implement proper form reset\n\n## TypeScript Integration\n- Use proper component types\n- Implement proper prop types\n- Use proper event types\n- Handle proper type inference\n- Use proper store types\n- Implement proper action types\n\n## Testing\n- Write proper unit tests\n- Implement proper component tests\n- Use proper testing libraries\n- Test stores properly\n- Implement proper mocking\n- Test async operations\n\n## Best Practices\n- Follow Svelte style guide\n- Use proper naming conventions\n- Keep components organized\n- Implement proper error handling\n- Use proper event handling\n- Document complex logic\n\n## Build and Tooling\n- Use Vite for development\n- Configure proper build setup\n- Use proper environment variables\n- Implement proper code splitting\n- Use proper asset handling\n- Configure proper optimization",
    "category": "framework"
  },
  "tailwind": {
    "name": "tailwind",
    "content": "# Tailwind CSS Best Practices\n\n## Project Setup\n- Use proper Tailwind configuration\n- Configure theme extension properly\n- Set up proper purge configuration\n- Use proper plugin integration\n- Configure custom spacing and breakpoints\n- Set up proper color palette\n\n## Component Styling\n- Use utility classes over custom CSS\n- Group related utilities with @apply when needed\n- Use proper responsive design utilities\n- Implement dark mode properly\n- Use proper state variants\n- Keep component styles consistent\n\n## Layout\n- Use Flexbox and Grid utilities effectively\n- Implement proper spacing system\n- Use container queries when needed\n- Implement proper responsive breakpoints\n- Use proper padding and margin utilities\n- Implement proper alignment utilities\n\n## Typography\n- Use proper font size utilities\n- Implement proper line height\n- Use proper font weight utilities\n- Configure custom fonts properly\n- Use proper text alignment\n- Implement proper text decoration\n\n## Colors\n- Use semantic color naming\n- Implement proper color contrast\n- Use opacity utilities effectively\n- Configure custom colors properly\n- Use proper gradient utilities\n- Implement proper hover states\n\n## Components\n- Use shadcn/ui components when available\n- Extend components properly\n- Keep component variants consistent\n- Implement proper animations\n- Use proper transition utilities\n- Keep accessibility in mind\n\n## Responsive Design\n- Use mobile-first approach\n- Implement proper breakpoints\n- Use container queries effectively\n- Handle different screen sizes properly\n- Implement proper responsive typography\n- Use proper responsive spacing\n\n## Performance\n- Use proper purge configuration\n- Minimize custom CSS\n- Use proper caching strategies\n- Implement proper code splitting\n- Optimize for production\n- Monitor bundle size\n\n## Best Practices\n- Follow naming conventions\n- Keep styles organized\n- Use proper documentation\n- Implement proper testing\n- Follow accessibility guidelines\n- Use proper version control",
    "category": "style"
  },
  "typescript": {
    "name": "typescript",
    "content": "# TypeScript Best Practices\n\n## Type System\n- Prefer interfaces over types for object definitions\n- Use type for unions, intersections, and mapped types\n- Avoid using `any`, prefer `unknown` for unknown types\n- Use strict TypeScript configuration\n- Leverage TypeScript's built-in utility types\n- Use generics for reusable type patterns\n\n## Naming Conventions\n- Use PascalCase for type names and interfaces\n- Use camelCase for variables and functions\n- Use UPPER_CASE for constants\n- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)\n- Prefix interfaces for React props with 'Props' (e.g., ButtonProps)\n\n## Code Organization\n- Keep type definitions close to where they're used\n- Export types and interfaces from dedicated type files when shared\n- Use barrel exports (index.ts) for organizing exports\n- Place shared types in a `types` directory\n- Co-locate component props with their components\n\n## Functions\n- Use explicit return types for public functions\n- Use arrow functions for callbacks and methods\n- Implement proper error handling with custom error types\n- Use function overloads for complex type scenarios\n- Prefer async/await over Promises\n\n## Best Practices\n- Enable strict mode in tsconfig.json\n- Use readonly for immutable properties\n- Leverage discriminated unions for type safety\n- Use type guards for runtime type checking\n- Implement proper null checking\n- Avoid type assertions unless necessary\n\n## Error Handling\n- Create custom error types for domain-specific errors\n- Use Result types for operations that can fail\n- Implement proper error boundaries\n- Use try-catch blocks with typed catch clauses\n- Handle Promise rejections properly\n\n## Patterns\n- Use the Builder pattern for complex object creation\n- Implement the Repository pattern for data access\n- Use the Factory pattern for object creation\n- Leverage dependency injection\n- Use the Module pattern for encapsulation",
    "category": "language"
  },
  "vue": {
    "name": "vue",
    "content": "# Vue.js Best Practices\n\n## Component Structure\n- Use Composition API over Options API\n- Keep components small and focused\n- Use proper TypeScript integration\n- Implement proper props validation\n- Use proper emit declarations\n- Keep template logic minimal\n\n## Composition API\n- Use proper ref and reactive\n- Implement proper lifecycle hooks\n- Use composables for reusable logic\n- Keep setup function clean\n- Use proper computed properties\n- Implement proper watchers\n\n## State Management\n- Use Pinia for state management\n- Keep stores modular\n- Use proper state composition\n- Implement proper actions\n- Use proper getters\n- Handle async state properly\n\n## Performance\n- Use proper component lazy loading\n- Implement proper caching\n- Use proper computed properties\n- Avoid unnecessary watchers\n- Use proper v-show vs v-if\n- Implement proper key management\n\n## Routing\n- Use Vue Router properly\n- Implement proper navigation guards\n- Use proper route meta fields\n- Handle route params properly\n- Implement proper lazy loading\n- Use proper navigation methods\n\n## Forms\n- Use v-model properly\n- Implement proper validation\n- Handle form submission properly\n- Show proper loading states\n- Use proper error handling\n- Implement proper form reset\n\n## TypeScript Integration\n- Use proper component type definitions\n- Implement proper prop types\n- Use proper emit declarations\n- Handle proper type inference\n- Use proper composable types\n- Implement proper store types\n\n## Testing\n- Write proper unit tests\n- Implement proper component tests\n- Use Vue Test Utils properly\n- Test composables properly\n- Implement proper mocking\n- Test async operations\n\n## Best Practices\n- Follow Vue style guide\n- Use proper naming conventions\n- Keep components organized\n- Implement proper error handling\n- Use proper event handling\n- Document complex logic\n\n## Build and Tooling\n- Use Vite for development\n- Configure proper build setup\n- Use proper environment variables\n- Implement proper code splitting\n- Use proper asset handling\n- Configure proper optimization",
    "category": "framework"
  },
  "react-typescript": {
    "name": "react-typescript",
    "content": "# React Best Practices\n\n## Component Structure\n- Use functional components over class components\n- Keep components small and focused\n- Extract reusable logic into custom hooks\n- Use composition over inheritance\n- Implement proper prop types with TypeScript\n- Split large components into smaller, focused ones\n\n## Hooks\n- Follow the Rules of Hooks\n- Use custom hooks for reusable logic\n- Keep hooks focused and simple\n- Use appropriate dependency arrays in useEffect\n- Implement cleanup in useEffect when needed\n- Avoid nested hooks\n\n## State Management\n- Use useState for local component state\n- Implement useReducer for complex state logic\n- Use Context API for shared state\n- Keep state as close to where it's used as possible\n- Avoid prop drilling through proper state management\n- Use state management libraries only when necessary\n\n## Performance\n- Implement proper memoization (useMemo, useCallback)\n- Use React.memo for expensive components\n- Avoid unnecessary re-renders\n- Implement proper lazy loading\n- Use proper key props in lists\n- Profile and optimize render performance\n\n## Forms\n- Use controlled components for form inputs\n- Implement proper form validation\n- Handle form submission states properly\n- Show appropriate loading and error states\n- Use form libraries for complex forms\n- Implement proper accessibility for forms\n\n## Error Handling\n- Implement Error Boundaries\n- Handle async errors properly\n- Show user-friendly error messages\n- Implement proper fallback UI\n- Log errors appropriately\n- Handle edge cases gracefully\n\n## Testing\n- Write unit tests for components\n- Implement integration tests for complex flows\n- Use React Testing Library\n- Test user interactions\n- Test error scenarios\n- Implement proper mock data\n\n## Accessibility\n- Use semantic HTML elements\n- Implement proper ARIA attributes\n- Ensure keyboard navigation\n- Test with screen readers\n- Handle focus management\n- Provide proper alt text for images\n\n## Code Organization\n- Group related components together\n- Use proper file naming conventions\n- Implement proper directory structure\n- Keep styles close to components\n- Use proper imports/exports\n- Document complex component logic\n\n---\n\n# TypeScript Best Practices\n\n## Type System\n- Prefer interfaces over types for object definitions\n- Use type for unions, intersections, and mapped types\n- Avoid using `any`, prefer `unknown` for unknown types\n- Use strict TypeScript configuration\n- Leverage TypeScript's built-in utility types\n- Use generics for reusable type patterns\n\n## Naming Conventions\n- Use PascalCase for type names and interfaces\n- Use camelCase for variables and functions\n- Use UPPER_CASE for constants\n- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)\n- Prefix interfaces for React props with 'Props' (e.g., ButtonProps)\n\n## Code Organization\n- Keep type definitions close to where they're used\n- Export types and interfaces from dedicated type files when shared\n- Use barrel exports (index.ts) for organizing exports\n- Place shared types in a `types` directory\n- Co-locate component props with their components\n\n## Functions\n- Use explicit return types for public functions\n- Use arrow functions for callbacks and methods\n- Implement proper error handling with custom error types\n- Use function overloads for complex type scenarios\n- Prefer async/await over Promises\n\n## Best Practices\n- Enable strict mode in tsconfig.json\n- Use readonly for immutable properties\n- Leverage discriminated unions for type safety\n- Use type guards for runtime type checking\n- Implement proper null checking\n- Avoid type assertions unless necessary\n\n## Error Handling\n- Create custom error types for domain-specific errors\n- Use Result types for operations that can fail\n- Implement proper error boundaries\n- Use try-catch blocks with typed catch clauses\n- Handle Promise rejections properly\n\n## Patterns\n- Use the Builder pattern for complex object creation\n- Implement the Repository pattern for data access\n- Use the Factory pattern for object creation\n- Leverage dependency injection\n- Use the Module pattern for encapsulation",
    "category": "composite"
  },
  "nextjs-typescript": {
    "name": "nextjs-typescript",
    "content": "# Next.js Best Practices\n\n## Project Structure\n- Use the App Router directory structure\n- Place components in `app` directory for route-specific components\n- Place shared components in `components` directory\n- Place utilities and helpers in `lib` directory\n- Use lowercase with dashes for directories (e.g., `components/auth-wizard`)\n\n## Components\n- Use Server Components by default\n- Mark client components explicitly with 'use client'\n- Wrap client components in Suspense with fallback\n- Use dynamic loading for non-critical components\n- Implement proper error boundaries\n- Place static content and interfaces at file end\n\n## Performance\n- Optimize images: Use WebP format, size data, lazy loading\n- Minimize use of 'useEffect' and 'setState'\n- Favor Server Components (RSC) where possible\n- Use dynamic loading for non-critical components\n- Implement proper caching strategies\n\n## Data Fetching\n- Use Server Components for data fetching when possible\n- Implement proper error handling for data fetching\n- Use appropriate caching strategies\n- Handle loading and error states appropriately\n\n## Routing\n- Use the App Router conventions\n- Implement proper loading and error states for routes\n- Use dynamic routes appropriately\n- Handle parallel routes when needed\n\n## Forms and Validation\n- Use Zod for form validation\n- Implement proper server-side validation\n- Handle form errors appropriately\n- Show loading states during form submission\n\n## State Management\n- Minimize client-side state\n- Use React Context sparingly\n- Prefer server state when possible\n- Implement proper loading states\n\n---\n\n# TypeScript Best Practices\n\n## Type System\n- Prefer interfaces over types for object definitions\n- Use type for unions, intersections, and mapped types\n- Avoid using `any`, prefer `unknown` for unknown types\n- Use strict TypeScript configuration\n- Leverage TypeScript's built-in utility types\n- Use generics for reusable type patterns\n\n## Naming Conventions\n- Use PascalCase for type names and interfaces\n- Use camelCase for variables and functions\n- Use UPPER_CASE for constants\n- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)\n- Prefix interfaces for React props with 'Props' (e.g., ButtonProps)\n\n## Code Organization\n- Keep type definitions close to where they're used\n- Export types and interfaces from dedicated type files when shared\n- Use barrel exports (index.ts) for organizing exports\n- Place shared types in a `types` directory\n- Co-locate component props with their components\n\n## Functions\n- Use explicit return types for public functions\n- Use arrow functions for callbacks and methods\n- Implement proper error handling with custom error types\n- Use function overloads for complex type scenarios\n- Prefer async/await over Promises\n\n## Best Practices\n- Enable strict mode in tsconfig.json\n- Use readonly for immutable properties\n- Leverage discriminated unions for type safety\n- Use type guards for runtime type checking\n- Implement proper null checking\n- Avoid type assertions unless necessary\n\n## Error Handling\n- Create custom error types for domain-specific errors\n- Use Result types for operations that can fail\n- Implement proper error boundaries\n- Use try-catch blocks with typed catch clauses\n- Handle Promise rejections properly\n\n## Patterns\n- Use the Builder pattern for complex object creation\n- Implement the Repository pattern for data access\n- Use the Factory pattern for object creation\n- Leverage dependency injection\n- Use the Module pattern for encapsulation\n\n---\n\n# Tailwind CSS Best Practices\n\n## Project Setup\n- Use proper Tailwind configuration\n- Configure theme extension properly\n- Set up proper purge configuration\n- Use proper plugin integration\n- Configure custom spacing and breakpoints\n- Set up proper color palette\n\n## Component Styling\n- Use utility classes over custom CSS\n- Group related utilities with @apply when needed\n- Use proper responsive design utilities\n- Implement dark mode properly\n- Use proper state variants\n- Keep component styles consistent\n\n## Layout\n- Use Flexbox and Grid utilities effectively\n- Implement proper spacing system\n- Use container queries when needed\n- Implement proper responsive breakpoints\n- Use proper padding and margin utilities\n- Implement proper alignment utilities\n\n## Typography\n- Use proper font size utilities\n- Implement proper line height\n- Use proper font weight utilities\n- Configure custom fonts properly\n- Use proper text alignment\n- Implement proper text decoration\n\n## Colors\n- Use semantic color naming\n- Implement proper color contrast\n- Use opacity utilities effectively\n- Configure custom colors properly\n- Use proper gradient utilities\n- Implement proper hover states\n\n## Components\n- Use shadcn/ui components when available\n- Extend components properly\n- Keep component variants consistent\n- Implement proper animations\n- Use proper transition utilities\n- Keep accessibility in mind\n\n## Responsive Design\n- Use mobile-first approach\n- Implement proper breakpoints\n- Use container queries effectively\n- Handle different screen sizes properly\n- Implement proper responsive typography\n- Use proper responsive spacing\n\n## Performance\n- Use proper purge configuration\n- Minimize custom CSS\n- Use proper caching strategies\n- Implement proper code splitting\n- Optimize for production\n- Monitor bundle size\n\n## Best Practices\n- Follow naming conventions\n- Keep styles organized\n- Use proper documentation\n- Implement proper testing\n- Follow accessibility guidelines\n- Use proper version control",
    "category": "composite"
  },
  "fastapi-python": {
    "name": "fastapi-python",
    "content": "# Python Best Practices\n\n## Project Structure\n- Use src-layout with `src/your_package_name/`\n- Place tests in `tests/` directory parallel to `src/`\n- Keep configuration in `config/` or as environment variables\n- Store requirements in `requirements.txt` or `pyproject.toml`\n- Place static files in `static/` directory\n- Use `templates/` for Jinja2 templates\n\n## Code Style\n- Follow Black code formatting\n- Use isort for import sorting\n- Follow PEP 8 naming conventions:\n  - snake_case for functions and variables\n  - PascalCase for classes\n  - UPPER_CASE for constants\n- Maximum line length of 88 characters (Black default)\n- Use absolute imports over relative imports\n\n## Type Hints\n- Use type hints for all function parameters and returns\n- Import types from `typing` module\n- Use `Optional[Type]` instead of `Type | None`\n- Use `TypeVar` for generic types\n- Define custom types in `types.py`\n- Use `Protocol` for duck typing\n\n## Flask Structure\n- Use Flask factory pattern\n- Organize routes using Blueprints\n- Use Flask-SQLAlchemy for database\n- Implement proper error handlers\n- Use Flask-Login for authentication\n- Structure views with proper separation of concerns\n\n## Database\n- Use SQLAlchemy ORM\n- Implement database migrations with Alembic\n- Use proper connection pooling\n- Define models in separate modules\n- Implement proper relationships\n- Use proper indexing strategies\n\n## Authentication\n- Use Flask-Login for session management\n- Implement Google OAuth using Flask-OAuth\n- Hash passwords with bcrypt\n- Use proper session security\n- Implement CSRF protection\n- Use proper role-based access control\n\n## API Design\n- Use Flask-RESTful for REST APIs\n- Implement proper request validation\n- Use proper HTTP status codes\n- Handle errors consistently\n- Use proper response formats\n- Implement proper rate limiting\n\n## Testing\n- Use pytest for testing\n- Write tests for all routes\n- Use pytest-cov for coverage\n- Implement proper fixtures\n- Use proper mocking with pytest-mock\n- Test all error scenarios\n\n## Security\n- Use HTTPS in production\n- Implement proper CORS\n- Sanitize all user inputs\n- Use proper session configuration\n- Implement proper logging\n- Follow OWASP guidelines\n\n## Performance\n- Use proper caching with Flask-Caching\n- Implement database query optimization\n- Use proper connection pooling\n- Implement proper pagination\n- Use background tasks for heavy operations\n- Monitor application performance\n\n## Error Handling\n- Create custom exception classes\n- Use proper try-except blocks\n- Implement proper logging\n- Return proper error responses\n- Handle edge cases properly\n- Use proper error messages\n\n## Documentation\n- Use Google-style docstrings\n- Document all public APIs\n- Keep README.md updated\n- Use proper inline comments\n- Generate API documentation\n- Document environment setup\n\n## Development Workflow\n- Use virtual environments (venv)\n- Implement pre-commit hooks\n- Use proper Git workflow\n- Follow semantic versioning\n- Use proper CI/CD practices\n- Implement proper logging\n\n## Dependencies\n- Pin dependency versions\n- Use requirements.txt for production\n- Separate dev dependencies\n- Use proper package versions\n- Regularly update dependencies\n- Check for security vulnerabilities\n\n---\n\n# FastAPI Best Practices\n\n## Project Structure\n- Use proper directory structure\n- Implement proper module organization\n- Use proper dependency injection\n- Keep routes organized by domain\n- Implement proper middleware\n- Use proper configuration management\n\n## API Design\n- Use proper HTTP methods\n- Implement proper status codes\n- Use proper request/response models\n- Implement proper validation\n- Use proper error handling\n- Document APIs with OpenAPI\n\n## Models\n- Use Pydantic models\n- Implement proper validation\n- Use proper type hints\n- Keep models organized\n- Use proper inheritance\n- Implement proper serialization\n\n## Database\n- Use proper ORM (SQLAlchemy)\n- Implement proper migrations\n- Use proper connection pooling\n- Implement proper transactions\n- Use proper query optimization\n- Handle database errors properly\n\n## Authentication\n- Implement proper JWT authentication\n- Use proper password hashing\n- Implement proper role-based access\n- Use proper session management\n- Implement proper OAuth2\n- Handle authentication errors properly\n\n## Security\n- Implement proper CORS\n- Use proper rate limiting\n- Implement proper input validation\n- Use proper security headers\n- Handle security errors properly\n- Implement proper logging\n\n## Performance\n- Use proper caching\n- Implement proper async operations\n- Use proper background tasks\n- Implement proper connection pooling\n- Use proper query optimization\n- Monitor performance metrics\n\n## Testing\n- Write proper unit tests\n- Implement proper integration tests\n- Use proper test fixtures\n- Implement proper mocking\n- Test error scenarios\n- Use proper test coverage\n\n## Deployment\n- Use proper Docker configuration\n- Implement proper CI/CD\n- Use proper environment variables\n- Implement proper logging\n- Use proper monitoring\n- Handle deployment errors properly\n\n## Documentation\n- Use proper docstrings\n- Implement proper API documentation\n- Use proper type hints\n- Keep documentation updated\n- Document error scenarios\n- Use proper versioning\n\n---\n\n# Database Best Practices\n\n## Prisma Setup\n- Use proper schema design\n- Implement proper migrations\n- Use proper relation definitions\n- Configure proper connection\n- Implement proper seeding\n- Use proper client setup\n\n## Prisma Models\n- Use proper model naming\n- Implement proper relations\n- Use proper field types\n- Define proper indexes\n- Implement proper constraints\n- Use proper enums\n\n## Prisma Queries\n- Use proper query optimization\n- Implement proper filtering\n- Use proper relations loading\n- Handle transactions properly\n- Implement proper pagination\n- Use proper aggregations\n\n## Supabase Setup\n- Configure proper project setup\n- Implement proper authentication\n- Use proper database setup\n- Configure proper storage\n- Implement proper policies\n- Use proper client setup\n\n## Supabase Security\n- Implement proper RLS policies\n- Use proper authentication\n- Configure proper permissions\n- Handle sensitive data properly\n- Implement proper backups\n- Use proper encryption\n\n## Supabase Queries\n- Use proper query optimization\n- Implement proper filtering\n- Use proper joins\n- Handle real-time properly\n- Implement proper pagination\n- Use proper functions\n\n## Database Design\n- Use proper normalization\n- Implement proper indexing\n- Use proper constraints\n- Define proper relations\n- Implement proper cascades\n- Use proper data types\n\n## Performance\n- Use proper connection pooling\n- Implement proper caching\n- Use proper query optimization\n- Handle N+1 queries properly\n- Implement proper batching\n- Monitor performance metrics\n\n## Security\n- Use proper authentication\n- Implement proper authorization\n- Handle sensitive data properly\n- Use proper encryption\n- Implement proper backups\n- Monitor security issues\n\n## Best Practices\n- Follow database conventions\n- Use proper migrations\n- Implement proper versioning\n- Handle errors properly\n- Document schema properly\n- Monitor database health",
    "category": "composite"
  }
};

export const templateCategories: Record<string, string[]> = {
  framework: ['react', 'vue', 'svelte', 'nextjs'],
  language: ['typescript', 'python', 'javascript'],
  style: ['tailwind', 'clean-code', 'codequality'],
  backend: ['node-express', 'fastapi', 'database'],
  workflow: ['gitflow'],
  composite: ['react-typescript', 'nextjs-typescript', 'fastapi-python']
};

export function getTemplatesByCategory(category: string): Template[] {
  const categoryTemplates = templateCategories[category] || [];
  return categoryTemplates
    .map((name: string) => templates[name])
    .filter(Boolean);
}

export function searchTemplates(query: string): Template[] {
  const lowerQuery = query.toLowerCase();
  return Object.values(templates).filter(template => 
    template.name.toLowerCase().includes(lowerQuery) ||
    template.content.toLowerCase().includes(lowerQuery)
  );
}
